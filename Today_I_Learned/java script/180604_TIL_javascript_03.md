## coding
>함수와 자료구조를 만드는것

### 객체와 인스턴스가 무엇이 다른가 ? 
- 객체 = 어떤 프로퍼티로 어떤 데이터로 구성되어있다
- 인스턴스 = 객체를 생성한 결과 
- 인스턴스라고 굳이 표현할때 = '메모리의 실체다'<br>
라고 강조하고싶을 때
- 평상시에는 객체라고 칭한다 

---

# 함수

<!-- (함수명은 대게 잘 안쓴다) -->
* 함수명 = 자기 자신을 호출하거나, 디버깅 할때 사용하기위해
* 함수 선언식과 함수 표현식의 차이 = 함수 호이스팅의 차이 <br>
( 함수 선언식은 __자바스크립트 엔진이 함수 표현식으로 바꾼다__ 그래서 같아 보이지만 호이스팅의 차이가 있다) 
* 변수 호이스팅 = 선언문 이전에 호출하면 에러다 = 언디파인드
* 함수 호이스팅 = 함수 선언 이전에 호출이 가능하다
* 상식선에서 선언문 이전에 참조하는 행위를 하면 안되는 것이기 때문에 지양한다. 때문에 함수 표현식으로 사용하는 것을 지향한다
* 함수표현식도 변수 호이스팅과 같은 방식이기때문에 언디파인드가 나온다 
* 제일 좋은방법은 선언문 이전에 호출하지 않는 것 이다 = __정석대로 쓰자__

---

# 매개변수 = parameter

* , 콤마로 구분해서 이어붙일 수 있다
* foo(1)에서 (1)은 인자(인수)=아규먼트다 <br>
var foo = function (p1, p2)에서 (p1,p2)는 파라미터 즉 매개변수이다
* 매개변수 = 지역변수이다

---

# call-by-value

* 매개변수의 레퍼런스타입(객체)를 변경하면<br>
함수 바깥에 있는 객체도 따라 변한다
* 기본자료형은 절대 변하지 않는다
* pass-by-value 개념과 같다고 생각하면 된다

---

# 반환값

* 자신을 호출한 코드 = 콜러
* 실행 후 밖으로 빠져나가는 것 = 리턴문<br>
리턴문 뒤에 쓴 코드는 무의미한 코드가 된다<br>
(리턴문이 실행되면 함수 바깥으로 빠져나가기 때문)
* 여러개의 데이터를 어떻게 묶을까 ? 하는 것 = 자료구조 
* __배열__ = 배열은 순서가 있다, 순회할 수 있다, for문으로 돌릴 수 있다<br>(for문은 순서가 있어야 하고 갯수가 있어야 한다. 그래야 몇번을 돌릴 줄 아는 것)


---

# 함수 객체의 프로퍼티

> 자료구조는 객체일수도있고 , 배열일 수도 있다
> 
    * 콜러는 함수객체의 프로퍼티이다 
    * 콜러 = 나를 누가 불렀느냐라는 정보를 담고있음
    * lenth = 함수 객체가 가지고 있는 매개변수의 갯수 
    * 코드의 가장 바깥부분 = 전역
    * 아규먼츠(인수들) = 함수객체만이 가지고 있는 독특한 프로퍼티 
    * 순서를 보장하는 자료구조 = 배열
    * Name 프로퍼티 = 디버그가 사용하도록 붙여주는 이름이다 , 재귀적으로 호출할 때 사용한다 

    Console.dir = 객체를 내부까지 싹 다 들여다볼때 사용
    (비표준 = 크롬이지원하는메소드이기때문에 크롬에서만될 확률이 큼)

    매개변수를 선언할 수 없는 케이스도 있다
    (ex.인수로 전달한 모든것을 모조리 통계를 내어라 인수가 1개일 수도 100개일 수도 있다 라고 할 수 있다 그럴때를 대비해 아규먼트라는 게 있다)
    
* 객체는 for문으로 돌리면 순서가 보장되지 않기때문에 사용하지 않는다
* 순서가 있는 것(프로퍼티에 순서를 담고 있는 객체) = 유사배열객체
* 순회하려면 lenth가 있어야한다
* 유사배열객체는 대괄호 표기법으로 봐야한다
* ___함수는 객체이므로 함수객체가 가지고 있는 독특한 프로퍼티가 있다 , 천번째가 아규먼트 프로퍼티이고, 두번째로는 콜러 이다___

---

# __proto__프로퍼티

* 생성자함수는 첫번째 문자를 대문자로써서 일반함수가 아닌, 생성자함수임을 알린다 ex) function Person{}
* new가 일단 빈객체를 만들고 , this가 그 빈 객체를 가르키게 한다( 참조를 갖게한다)
* **생성자 함수 = 객체를 만들어낸다**
* 외워야하는 부분 문법 ->__모든 객체는 자신의 부모역할을 하는(상속) 객체를 가지고 있다 그 객체가 바로 프로토타입 객체이다__
* **모든 객체는 [[prototype]]프로퍼티를 갖는다** prototype의 참조가 된다 (부모를 찾아가는)
* **함수객체만 가지고 있을 수 있는 프로퍼티 = prototype**


>다시 한번 정리하면 함수 객체를 포함한 모든 객체가 가지고 있는 감춰진   
프로퍼티 =[[prototype]]이다

    * 따라서 함수 객체는 prototype과 [[prototype]]을
      둘 다 가지고 있다  
    * 상속은 부모것을 자식이 쓰는 것(자식것을 부모는 쓸 수 없다) 
    * [[prototype]](ES의 표준을 얘기하는 것이고)
       __proto__(같은 의미지만 이름의 표준을 안 따라서 그런 것)
    
    그러므로 [[prototype]] = __proto__ 이다



# prototype 프로퍼티

* 가리키는 대상은 똑같으나 누가 바라보느냐의 입장(관점)이 다름
생성자 함수의 입장에서와 자식의 입장이 다르다
* 함수는 여러가지 형태를 가질 수 있다

# 즉시호출함수표현식

* IIFE = 함수의 정의와 동시에 실행되는 함수, 단 한번만 호출할 수 있다 (다음에호출하겠다는 의도가 아닌 딱 한번만 호출하겠다는 의도를 담고있음)
* 초기화 처리등의 사용을 할 수 있다
* 자바스크립트는 함수외부(전역영역)에 있는것은 그냥 실행해버린다 , 전역변수를 사용하지 않기위해 사용하는 것 = 즉시호출함수표현식<br>
즉 임의적으로 스코프를 만들어주는것이다
    ##### *변수 = 기억해야할 값을 저장할 때 사용 

# 내부 함수

* 함수 내부에 있는 함수
* 함수 안에 함수를 사용한 것은 = 가장 바깥에 있는 함수 안에서만 의미가 있게 만들도록 의도 
* 지역변수는 함수 바깥으로 호출할 수 없다 


# call-back 함수

* 대부분 비동기처리에 사용한다 
* 명시적으로 호출되는 함수가 아니다
* 특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수이다


---


# 프로토타입 객체

## 프로토타입이란 ?

    클래스 기반의 상속과는 개념이 틀리다, 부모 역할을 하는 객체를 Prototype(프로토타입) 객체 또는 줄여서 Prototype(프로토타입)이라 한다.
    
**프로토타입객체라고 불러주는 게 더 정확한 표현이다**

* 객체리터럴 방식을 사용하면 클래스같은 것 없이 바로 사용할 수 있다
* 나의 것이 없어도 부모의 것이 있으면 부모것을 쓴다 = 상속
* 일반함수도 프로토타입을 갖고 있으나, 무의미하다.<br>
그렇기 때문에 생성자함수(new)를 사용하면 의미가 있게 되는 것이다
* This = 자신이 생성할 객체를 가리킨다
* 객체리터럴과 생성자함수로 만들었을때 가장 큰 차이 = 재상용성의 차이 구조적으로도 안정되고 메모리도 적게든다<br>
때문에 __[생성자함수를 사용하는 것은 상속관계를 가질 것이냐, 말것이냐 라는 의도가 있다]__
* 객체리터럴 = 단독적으로 사용할 경우
* 생성자함수 = 상속을 활용하여 재사용할 경우 


---

# 기본 자료형의 확장

* String이라는 생성자함수가 있다 = string(=기본자료형) 객체를 만드는 생성자
* 기본자료형의 객체를 래퍼(wrapper)함수라고 부른다 
* 내장 메소드 = 빌트인 메소드 (즉 객체에 소속되어야 한다)
* 기본자료형에 .(점)을 찍는 순간 내부적으로 스트링생성자함수를 가동시켜서 기본자료형을 객체화한다, 코드가 끝나면 다시 기본자료형을 돌아온다
* 감싼 객체를 만든다고 하여 래퍼(wrapper)객체 라고 한다
* Array 배열을 만들기위한 래퍼객체 / Number 숫자값을 객체를 만들기위한 래퍼객체 / Boolean / Math / Date 등등~ 확장형이 여러가지 있다 (자바스크립트가 우리에게 미리 만들어 주는 것, 이런 것들이 빌트인)


---

# 프로토타입 객체의 변경

* 억지로 바꿀 순 있지만, 지양한다. 즉, 하지 않아야하는 행동이다

---

# 빌트 인 오브젝트

* Native object(=빌트인오브젝트,글로벌오브젝츠)란 = ECMASCRIPT에 기재되어있는 객체들
* Host object = ECMASCRIPT에 기재되어 있지 않은 객체들


### 에러 객체
* 타언어와 달리 비동기 함수가 많다 , 비동기함수로 로직을 처리하는 경우가 대다수이다 
* 비동기방식에서는 에러처리가 안된다

### 기본자료형과 래퍼객체
* .을 찍으면 래퍼객체로 확 바뀌어서 동작한다

### 호스트 객체
* 환경의 영향을 받는 객체들

---


# 전역 객체(global object)
##### *(반대개념)지역 객체(local object)
* 윈도우 안에 모조리 들어있다
* constructor가 없다 (의도적으로 만들 수 없다)
* 전역변수는 윈도우계체의 자식이다 
* 전역함수도 윈도우계체의 자식이다


# 로컬호스트 
* 내 컴퓨터에 서버환경을 만들고 외부에서 통신하는것과 똑같은 방식으로 통신을 하면서 개발을 할 수 있다
* Port 라는 번호를 주어서 서버에 번호를 매겨줌 번호가 있을수도 있고 , 없을수도 있다  없으면 기본적으로 80이 날라간다 
* / 는 루트폴더를 나타냄
* ? 는 쿼리 파라미터 , 써치파라미터라고도함 = 서버에게 부가적인 정보를 알려주는 것
* #=id / 해쉬 / 플래그먼트 라고도 함 (페이지 내부에서 페이지를 왔다갔다 할때 스크롤하고싶을 때 사용한다, 페이지 전환이 안 일어난다) > 그걸 싱글 SPA라고 한다 

---


# 용어정리

* 변수 = 기억해야할 값을 저장할 때 사용 
* 코드의 가장 바깥부분 = 전역
* This = 자신이 생성할 객체를 가리킨다
* 함수 선언문 = 함수 객체 
* 반환용변수 = 템포러리변수
* 전역객체 = 글로벌오브젝트
* 스코프 = 유효범위
---

# etc
* 여러개의 데이터를 어떻게 묶을까 ? 하는 것 = 자료구조 
* 배열은 순서가 있다, 순회할 수 있다(for문으로 돌릴 수 있다,순서가있어야되고 갯수가 있어야한다 그래야 몇번을 돌릴 줄 아는 것) = 순서가 보장되고 갯수가있다
* 함수는 = 객체다 = 프로퍼티가 있다 
* 함수객체는 일반객체와는 틀리다 
* 프로퍼티 이름은 = 무조건 문자열이다
* 함수 객체와 일반 객체의 차이는 함수객체는 호출할 수 있고 일반 객체는 호출 할 수 없다
* 변수의 중복 선언 (한 스코프에 있는것처럼 움직이는것 = 영향을 주는 것 독립적일 수 없는 것)= 모듈화를 지원하지 않는다 라는 의미
* 변수는 범위를 작게 써야한다 
* 전역변수는 안써야한다 (그방법은 함수내부에서 선언하는 방법뿐이다)
* 자바스크립트는 함수외부(전역영역)에 있는것은 그냥 실행해버린다 , 전역변수를 사용하지 않기위해 사용하는 것 = 즉시호출함수표현식 임의적으로 스코프를 만들어주는것이다 !
* 지역변수는 함수 바깥으로 호출할 수 없다 
* 함수 = 행위
* .(점)을 찍는 순간 기본자료형을 객체화한다, 코드가 끝나면 다시 기본자료형으로 돌아온다

> 스코프 = 변수의 생명주기 (변수도 죽습니다..)<br>
> 
> 변수가 죽지 않으면 = 사용하지 않지만 애플리케이션이 죽을때까지 메모리를 계속 잡아먹고 있는 상태가 됨 = 전역변수 = 영원불사,<br>
> 
> 즉, 애플리케이션이 종료되지 않는 한 소멸하지 않는 상태<br>
> 때문에 유효범위를 만들어서 얘의 생명은 여기에서 여기까지야~ 라고 지정을 해주는것이 스코프 <br>
> 
> ex)자바스크립트는 함수 바디 내부가 스코프(유효범위)다른언어는 코드블럭 내부가 스코프 